---
title: JS引擎之垃圾回收
date: 2021-1-25
categories:
 - JavaScript
tags:
 - JS引擎
---



关于栈内存的垃圾回收是通过移动 ESP 指针来对执行上下文进行销毁操作的。具体可以看看内存机制那篇文章。

那么堆内存是怎么进行垃圾回收的呢？

## 引用计数法

我们先来说说最早也是已经被逐渐遗弃的垃圾回收算法，引用计数法。

这个算法的具体思路就是为每个对象分配一个计数器，当有其他对象引用这个对象时计数器加一，反之引用解除时减一。如果没有引用指向该对象，对象将被垃圾回收机制回收。

```js
var a = {};	// 此时这个对象的引用计数+1 (a在引用)
var b = a;	// 引用计数为2
a = null;	// 引用计数为1
b = null;	// 引用计数为0，GC将回收该对象
```

当是这个算法会有一个很大的弊端：无法对循环引用进行正确的回收

```js
function f(){
  var o = {};
  var o2 = {};
  o.a = o2; // o 引用 o2,o2的引用次数是1
  o2.a = o; // o2 引用 o,o的引用此时是1
}

f();
// 即时 o 和 o2 没有再被使用，但是它们的引用计数都不为0，无法被回收
```

那么 V8 引擎用的是什么垃圾回收算法呢？

## 新生代垃圾回收

V8 将堆内存分为新生代和老生代两个区域，**新生代中存放的是生存时间短的对象，老生代中存放的是生存时间久的对象。**

### Scavenge 算法

新生代区域中使用的是 Scavenge 算法，该算法会将新生区分为对象区域和空闲区域（也有叫 From 空间和 To 空间的，命名什么的无所谓啦，本质的思想是一样的）。新加入的对象会存放在对象区域，当对象区域快要被写满时，就会执行一次垃圾清除操作。

首先对对象区域的对象进行标记，在标记完成后将所有标记的对象复制到空闲区域，同时将这些对象有序地排列起来，这个过程也进行了整理，防止出现内存碎片。

复制完成后，对象区域与空闲区域进⾏角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去。

因为复制需要时间成本，所以新生区的空间会被设置得比较小。也正是因为新生区空间比较小，所以V8引擎采用**对象晋升策略**，也就是经过两次垃圾回收依然还存活的对象，会被移动到⽼生区中。

## 老生代垃圾回收

前面说了老生代中的对象一般存活时间较长，并且老生代中累计的空间一般都很大，所以不能采用 Scavenge 算法，那么老生代是采用什么垃圾回收算法的呢？

有两种算法：标记-清除算法和标记-压缩算法（标记-整理算法）

### 标记-清除算法

标记-清除算法分为两个阶段：

+ 标记阶段：从一组根元素开始（根元素可以理解为全局对象），递归遍历这组根元素，找所有从根开始引用的对象，然后找这些对象引用的对象，能够遍历到达的对象打上标记，然后继续递归遍历（深度优先遍历）。
+ 清除阶段：回收所有没有打上标记的对象

那么我们再看回刚才的循环引用问题，那两个对象从全局对象开始没有被遍历到。因此，这两个对象会被垃圾回收器回收，完美得解决循环引用的问题。

### 标记-压缩算法

标记-压缩算法与标记-清除算法的不同就在于清除阶段。

+ 标记-清除算法在清除时是直接处理，这个过程可能会产生大量的内存碎片。
+ 标记-压缩算法再清除时是对所有存活对象统一挪到堆内存的一端，然后直接清理掉边界以外的内存



## 增量标记

我们知道 JS 引擎是单线程的，所以在执行垃圾回收的时候，需要将正在执行的脚本暂停下来，等到垃圾回收执行完成再恢复脚本的执行。所以如果垃圾回收的数据过大，导致垃圾回收的执行时间过久，那么应用的性能就会下降。

那么为了避免这个问题，V8 采用了**增量标记**，就是将标记过程分为一个个子过程，同时让标记的过程与JS脚本交替执行，直至标记完成。