---
title: 05 JS引擎如何执行一段JS代码
date: 2021-03-01
categories:
 - JavaScript
tags:
 - JS引擎
---



当前的编译语言主要分为编译型语言和解释型语言：

+ **编译型语言**在程序执行前需要经过**编译器**的编译过程，将源代码进行词法分析、语法分析、生成 AST =，然后优化代码，最后转换成机器码，**运行时不需要再重新编译**，可直接使用编译后的结果。例如 C 和 C++ 都是编译型语言
+ **解释型语言**是将源代码转换成中间代码，最后**每次运行时都需要解释器**对程序进行动态解释成机器码和执行。很明显解释型语言的执行速度要慢于编译型语言。例如 JavaScript 和 Python 都是解释型语言

而对于 V8 引擎来说，它执行 JS 代码会经过以下这些阶段：

1. Parse 阶段：V8 引擎将源代码经过语法分析和词法分析转换为 AST（抽象语法树）
2. Ignition 阶段：解释器将 AST 转换为字节码，进而对字节码逐行解释执行
3. TurboFan 阶段：编译器利用字节码将热点代码转换为可执行机器码保存起来



## 生成 AST

抽象语法树 AST 是对代码的结构化表示，例如

```js
var a = 2
```

这段代码会先经过两个阶段来转换为 AST

1. **词法分析**，将源码拆解成一个个 token（即语法上不能再分的，最小的单个字符或字符串）。如关键字 var、标识符 a、赋值运算符 =、文字2 这四个 token
2. **语法分析**，利用生成的 token，根据语法规则转为 AST。

最后转换为 AST 之后的 JSON 格式如下

```js
{
  "type": "Program",
  "start": 0,
  "end": 9,
  "body": [
    {
      "type": "VariableDeclaration",
      "start": 0,
      "end": 9,
      "declarations": [
        {
          "type": "VariableDeclarator",
          "start": 4,
          "end": 9,
          "id": {
            "type": "Identifier",
            "start": 4,
            "end": 5,
            "name": "a"
          },
          "init": {
            "type": "Literal",
            "start": 8,
            "end": 9,
            "value": 2,
            "raw": "2"
          }
        }
      ],
      "kind": "var"
    }
  ],
  "sourceType": "module"
}
```

前端中经常会用到的 Babel 中将 ES6 转换为 ES5 语法具体实现过程就会用到 AST，主要过程是将 ES6 源码转换为 AST，再将 ES6 语法的抽象语法树转成 ES5 的抽象语法树，最后利用它来生成 ES5 的源代码。

另外 ESlint 的原理也大致相同，先将源码转为 AST 后再利用它来检测代码规范




## 生成字节码

最早是没有生成字节码的步骤的，只是通过 AST 直接转为机器码，但是这样会带来几个问题，例如：机器码占用的空间远大于字节码占用的空间，由于 V8 需要消耗大量内存来存放转换后的机器码，若全部转为机器码的话会带来内存占用过大的问题，特别是内存不够大的手机。所以后来引入了字节码

那么什么是字节码呢？

字节码是介于 AST 和机器码之间的一种代码，需要通过解释器对字节逐行进行解释执行将其转换为机器码后才能执行，虽然仍需要生成机器码，但是省去了生成二进制文件的操作，大大降低了内存的压力。



## 执行代码

生成字节码之后，接下来就要进行执行阶段了。

解释器会对字节码逐条解释执行，在执行字节码的过程中，如果发现有热点代码（一段被重复执行多次的代码），那么编译器就会把该热点字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了。

这种字节码配合解释器和编译器的技术称为**即时编译（JIT）**，指解释器在解释执行字节码的同时，当发现某一部分代码变热后，便将该热点代码转换为机器码

