---
title: JS基础之类型转换
date: 2021-2-3
categories:
 - JavaScript
tags:
 - JS基础
---



## 1. 类型转换

在 JS 中类型转换有三种情况

+ 转换为布尔值
+ 转换为字符串
+ 转换为数字

基本的转换规则如下：

|                     原始值                     | 转换目标 |                             结果                             |
| :--------------------------------------------: | :------: | :----------------------------------------------------------: |
|                     number                     |  布尔值  |                   除了0、-0、NaN都为 true                    |
|                undefined、null                 |  布尔值  |                            false                             |
|                     string                     |  布尔值  |                    除了空字符串都为 true                     |
|                Symbol、引用类型                |  布尔值  |                             true                             |
| number、Boolean、Symbol、undefined、null、函数 |  字符串  |                     全都转为对应的字符串                     |
|                      数组                      |  字符串  | [1,2,[3,4]] => "1,2,3,4"、[1,2,null,4,undefined] => "1,2,,4," |
|                      对象                      |  字符串  |                      "[object Object]"                       |
|                     string                     |   数字   |                     '1' => 1、'a' => NaN                     |
|                   undefined                    |   数字   |                             NaN                              |
|                      null                      |   数字   |                              0                               |
|                     Symbol                     |   数字   |                           抛出错误                           |
|                    Boolean                     |   数字   |                    true 为 1、false 为 0                     |
|                      数组                      |   数字   |              将数组转为基础类型，在将其转为数字              |
|               除了数组的引用类型               |   数字   |                             NaN                              |



## 2. 引用类型转基础类型

引用类型转基础类型的时候，它会有如下的逻辑：

1. 如果存在 Symbol.toPrimitive() 方法，直接调用，返回该函数的返回结果
2. 调用 valueOf()，如果转换为基础数据类型，则直接返回（valueOf 是对象原型上的方法，默认值就是返回本身）
3. 调用 toString()，如果转换为基础数据类型，也直接返回（toString 是对象原型上的方法，默认值就是返回本身转为字符串的值）
4. 如果以上情况都没有发生，则抛出错误

```js
var obj = {
  [Symbol.toPrimitive](){
    return 1
  },
  toString() {
    return 2
  },
  valueOf() {
    return 3;
  }
}

console.log(obj + 3)	// 4
```



## 3. 四则运算符

对于除了加法运算符之外的运算符，只要其中一方为数字，另一方就会转为数字

```js
2 * [7]		// 14
2 - [7,1]	// NaN
[2] / [4]	// 0.5
```

对于加法运算符的话，它有以下的特点：

+ 如果其中一方是字符串，那么另一方也会转为字符串
+ 如果一方不是数字或字符串，那么它将会转为数字或字符串

```js
2 + '4'				// "24"
1 + undefined		// NaN
'1' + undefined		// "1undefined"
'a' + + 'b'			// "aNaN" ( +'b'会隐式转换为数字即 NaN )
1 + [1]				// "11" ( [1]会调用 toString 方法转为 "1" )
```



## 4. == 与 ===

=== 是严格相等，即左右两边不仅值要相等，类型也要相等。

== 是宽松相等，它涉及到类型的转换，具体的规则如下：

1. 如果两者类型相同，则直接比较值，并返回结果

2. 如果是 null 和 undefined 之间的比较，返回结果（null 和 undefined 之间相互宽松相等，并且也与自身相等，其他都**不**宽松相等）
3. 如果其中一方是布尔类型，则将布尔类型转为数字，再进行比较。
4. 如果是数字和字符串进行比较，则将字符串转为数字，再进行比较。
5. 如果其中一方为引用类型，则将引用类型转为基础类型，再进行比较。
6. NaN 与任何值都不相等，包括它自身。（要判断是否是 NaN 要使用 isNaN ）

```js
[] == 0				// true
[1,2] == "1,2"		// true
NaN == NaN			// false
['0'] == false		// true
null == undefined	// true
null == false		// false
[undefined] == 0	// true
2 == true			// false
[] == ![]			// true
```

我们来看看上面最后一条 [] == ![] 为何是true，它的转换步骤如下：

+ 首先 ![] 隐式转换为false
+ 然后根据规则 3 将 false 转为 0
+ 再根据规则5 将 [] 转为 ""
+ 再则根据规则4 将 "" 转为 0
+ 最后根据 1 比较得出 true



## 5.  一道有趣的面试题

> 如下面的代码，定义一个变量 a，使表达式为 true

```js
a == 1 && a == 2 && a == 3
```

根据类型的转换规则，我们可以想到将 a 定义为一个对象，当 a 进行宽松相等时会将其转为原始类型，所以我们可以让它的 Symbol.toPrimitive 或 valueOf 或 toString 方法被调用时触发自增即可

```js
var a = {
  count: 1,
  toString(){	// 这里当然可以改为 Symbol.toPrimitive 或者是 valueOf
    return this.count++;
  }
}
```

