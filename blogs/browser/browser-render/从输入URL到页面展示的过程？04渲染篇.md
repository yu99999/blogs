---
title: 从输入URL到页面展示的过程？04渲染篇
date: 2021-2-15
categories:
 - 浏览器
tags:
 - 浏览器渲染
---



## 1. 构建布局树

现在，我们已经有了 DOM 树和 DOM 树中的样式。接下来就是确定 DOM 树中**可见元素的几何位置**，这个过程就是构建布局树。

构建布局树具体有两个步骤：

1. 遍历 DOM 树中的所有可见节点，并添加到布局树中
2. 计算布局树中每个节点的位置信息

这样我们就有了一颗完整的布局树，这棵布局树只有可见节点，例如 `head` 和 `display: none` 的节点都没有在布局树上



## 2. 构建图层树

接下来，渲染引擎为了应对复杂的场景，比如3D变换、页面滚动或者使用 `z-index` 做为 z 轴对页面排序等。**渲染引擎为特定的节点生成专用的图层，并生成一颗图层树**。这些图层经过叠加后最终合成为完整的页面。（这里的图层指的是**合成层**）

### 合成层

在了解合成层前需要先了解下**渲染层**，由下图可以得知，一个 DOM 节点对应一个渲染对象，由渲染对象根据层叠上下文的划分，处于相同坐标空间（z 轴空间）的渲染对象，都将归于同一个渲染层中，而不同坐标空间的渲染对象将形成多个渲染层。

![16daf0c0a72be715](@img/16daf0c0a72be715.jpg)

当满足某些条件的渲染层将被提升为**合成层**，合成层能给我们带来不少好处：

+ 当需要 repaint 时，只需要 repaint 本身，不会影响到其他层
+ 合成层的位图能够交由 GPU 合成

那么如何将渲染层提升为合成层呢？有两种情况，一种是**显式合成**，一种是**隐式合成**

### 显式合成

我们可以通过设置某些 CSS 属性来提升为合成层

+ 通过 3D transforms：translate3d、translateZ
+ video、canvas、iframe 等元素
+ 通过 CSS 动画实现 opacity 或 transform 动画的转换
+ position: fixed 或 sticky
+ 具有 will-change 属性，且值为 opacity、transform、top、left、bottom、right 
+ 需要进行裁剪的地方

### 隐式合成

当**层叠等级低**的渲染层被提升为单独的合成层后，那么**层叠等级高**的渲染层都将提升为合成层。

隐式合成如果处理不当会有**层爆炸**的风险，若一个 `z-index` 很低的渲染层被提升为合成层后，层叠在它上面的渲染层都将提升为合成层，那么可能会产生几千个合成层。



## 3. 生成绘制列表

完成图层树的构建后，渲染引擎会对每个图层进行绘制，即将每个图层拆分成很多小的**绘制指令**，然后将这些指令按照顺序组成一个**绘制列表**。

我们可以通过打开开发者工具的 `Layers` 面板中的 `Profiler` 进行查看，下面以谷歌首页为例

<img src="@img/image-20210223004030284.png" alt="image-20210223004030284" style="zoom: 67%;" />

可以看到，谷歌首页被分为了两个层（document 和 滚动条），其中的  `Profiler` 就是一条条绘制指令



## 4. 生成图块、位图以及合成

一旦有了图层树以及对应的绘制列表之后就能进行绘制操作了，而绘制操作是交由渲染进程中的**合成线程**来执行的。

**合成线程**将图层分成一个个小块，并将这些图块交给**栅格线程**来生成**位图**，由图块生成位图就是栅格化。渲染进程维护了一个**栅格化线程池**，所有图块的栅格化都在线程池中进行。

另外，合成线程能够对栅格化线程池进行优先排序，以便利用视口附近的图块来优先生成位图。

当生成合成层的位图之后，会交由 **GPU 将多个位图进行合成**，这也就是常说的 GPU 硬件加速



## 5. 显示页面

栅格化后合成线程发送命令 "draw quad" 给浏览器进程后，浏览器进程将合成帧发送给显卡。

显卡的刷新频率一般是 60Hz，即一秒更新60帧图像，而显卡分为**前缓冲区**和**后缓冲区**，每次更新帧的时候是将帧发送给显卡的后缓冲区，显示的区是前缓冲区，当显卡将图像保存在后缓冲区，会自动将前缓冲区和后缓冲区对换位置，以达到页面更新。

这也就是为什么在执行一次动画过程中，当渲染引擎生成某些帧的时间过久，帧传给显卡不及时，而显卡的刷新频率不变，从而产生页面卡顿的现象。



